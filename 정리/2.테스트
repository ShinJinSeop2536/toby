>>스프링의 중요한 가치는 IoC/DI와 테스트 이다.

*IoC/DI : 오브제트의 설계와 생성, 관계, 사용헤 관하 기술*
*태스트 : 코드를 확신할 수 있게 해주고 , 변화에 유연하게 대처 할 수 있는 자신감을 주는 테스트 기술*

UserDaoTest다시보기
---------------------
>1장에서 매 단계를 확인하고 다양한 방법으로 초남감 UserDao 코드의 구조와 설계를 개선했고, 스프링을 적용해서 동작하게 만들었다. 
>코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 초남감 UserDao 가능을 수행한다,
>테스트를 통해 확인 할수 없었다면 확신 할 수 없었을 것이다.
>테스트란 코드가 정확히 동작하는지를 확인힌해서 확신할 수 있는 작업이다.

*테스트 -> 설계의 결함이 있는 작업 -> 결함을 제거하는 디버깅 작업 -> 확신을 가진 코드

웹을 톤한DaO 테스트 방법의 문제점
------------------------------

>보통 웹 프로그램에서 사용한는 DAO를 테스트하는 방법은 DAO를 만든 위 바로 테스트하지 않고, 서비스 계층 MVC 프레젠체이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다.
>웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이다.

##단점##
*모든 레이어의 기능을 다 만들고 나서야 태스트 가능*
>테스트를 하는 중에 에러가 나거나 테스트에 실패했다면, 과연 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요하다
>UserDao를 테스트 하고 피었는데 다른 계층의 코드와 컴포넌드, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 
>번거롭고, 오류가 있을 떄 빠르고 정확하게 대응하기 힘들다.

작은 단위의 테스트
-----------------

>테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하나.
>
>따라서  테스트는 작은  단위로 쪼개서 집중해서 할 수 있어야 한다.
>관심사의 분리하는 원리가 여기에 적용된다. 데스트의 관심이 다르다면 데스트할 대상을 분리하고 집중해서 접근해야 한다.

> UserDaoTest는 한 가지 관심에 집중할 수 있게  작은 단위로 만들어진 테스트다.
>간단히 IDE나 도스창에서도 테스트 수행이 가능하다. 에러가 나거나 원치 않은 결과가 나온다면, UserDao에 문제가 있는 것이니 원인을 빠르게 찾아낼 수 있다
> 이렇게 작은 단위의 코드드에 다해 테스트를 수행한 것은 *단위 테스트*라고 한다.
> 단위란 크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고, 작게 보자면 UserDao의 add() 메소드 하나만 가지고 하나의 단위라고 생각할수 있다.
> 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
>일반적으로 단위는 작을수 록 좋다. 단위를 넘어서는 다른 코드들을 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.
>DB의 상태가 매번 달달지고 , 테스트를 위해 DB를 특정 상태로 만들줄수 없다면 UserDaoTestrk 단위 데스트로서 가치가 없다
>통제 할수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다
>전 과정을 하나로 묵어서 테스트 할 필요가 있다. 각 된위 기능을 잘 동작하는데 묶어놓으면 안 되는 경우가 종종 발생하기 때문이다. 
>길고 많은 다위가 참여하는 테스트도 필요하다.
> 단위별로 테스틀르 먼저 진행하고 긴테스틀르 시작하면 예외가 발생하거나 테스트 실패할 수는 있겠지만 
>이미 각 단위별로 검증을 마치고 오류를 잡았으므로 훨씬 나을 것이다.
>단위 테스트가 필요한 이유눈 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하를 개발바 스스로 확인하기 위해서다.
>이떄 확인의 대상과 조건이 간다하고 명확할수록 좋다.  
>단위 테스트트 개발자 만든 코드를 스스로 확인하기 위해 사용하는데 이를 개발자 테스트 또느 프로그래머 테스트라고 한다.
>UserDaoTest은 작은 단위의 테이터 액세스 기능만을 테스트 하다 그 외의 계층이 참여하지 않기 떄문에  이는 단위 테스트이다.
>또한 설께하고 의도한 대로 동작했는지를 확인하기 떄문에 개발자 테스트라고 한다.

자동수행 테스트 코드
-----------------

>테스트는 자동으로 수행되도록 코드로 만들어지 것이 중요하다.
>테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어 져서 자동으로 수행될 쉬 있어야 한다는 건 매우 중요하다.
>애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 별도로 테스트용 클래스를 만들어서 테스트 코도를 넣는 편이 낫다.
>자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다.
> 단 한줄의 코드를 건드렸는 전체 기능에 영향을 주기도 한다. 에플리케이션에 김각한 문제를 일키지는 않을까 하는 두려움을 앞선다.
>그럴때 만들어둔 테스트가 있다면 가른 기능에 문제가 발생하지는 않는지 재빨리 확인 할 수 있다. 

지속적인 개선과 점진적인 개발을 위한 테스트
-----------------

>처음 부터 개발을 끝내고 검즘하려고 한다면, 아마 쏟아지는 에러로 원인을 찾는데 고심스러운 시간을 보내야 한다.
>하지만 일단 단순한 벙법으로 정상적인 코드를 만들어 테스트 해뒀기 떄문에 작운 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다. 
>테스트를 수행해서 확신을 가지는 코드가 되었다.

UserDaoTest의 문제점
-----------------

*수동 확인 작업의 번거로움*
>사람의 눈으로 확인하는 과정이 필요하다.
>add()의 정보와 get()의 정보가 일치 하는지 테스트 코드는 확인해 주진 않는다.
>성공적으로 되고 있는지 확인하는 것은 사람의 책임이다.
>검증해야 하는 양이 많고 복잡해지면 역시 불편하고, 발견하지 못하고 넘어가는 실수를 할 가능성이 있다.

*실행  작업의 번거로움*
>가단한 실행 가능한 main() 메소드라고 하더라도 매번 그것을 실행하는 것은 제법 번거롭다.

테스트의 효율적인 수행과 결과 관리
-----------------

>프레임워크의 기본 동작원리가 바로 제어의 역저(IoC)이다. 개발자가 만든 크래스의 오브젝트를 생성하고 샐행하는 일은 프레임워크에 의해 진행된다.
>main()메소드노 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들필요도 없다.
>main()메소드 테스트는 프레임워크에 적용하기 적합하지 않다. main()메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이다.

*JUnit*
>1.public 메소드 선언
>2.@Test라는  애노테이션을 붙혀주는 것이다. 

검증 코드 전환
-----------------

*JUnit 제공하는 방법*
>if(!user.getName().equals(user2.getName())){.....}  = assertThat(user2.getName(), is(user.getName()));

개발자를 위한 테스팅 프레임워크 JUnit
-----------------

>스프링 테스트 모듈도 JUnit을 이용한다.
>JUnitCore를 이용해 테스트를 실행하고 콘솔에 출력된하는 방법이 가장 간단하다. 
>하지만 테스트의 수가 많아지면 관리하기 어렵다
>가장 좋은 방법은 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.
>@Test가 들어 있는 테스트 클래스를 선택환뒤에, JUnit Test를 선택하면 main() 메소드를 만들지 않아도 된다
>테스가 시작 된면 JUnit 테스트 정보를 뷰로 표시 해 준다.
>뷰에서 테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수를  확인할 수 있다/
>JUnit은 한 번에 여러 테스트 클래스를 동시에 실행할 수 있다. 이런 면에서 JUnitCore를 사용하는 것보다 훨씬 편리하다.
>JUnit은 간단하고 직관적이며 소스와 긴밀하게 연동돼서 결과를 볼 수 있다. 
>실행 할 떄는 IDE의 지원을 받는 것이 가장 편리하다.

빌드 툴 
-----------------

>프로젝트의 빌드를 위해 ANT나 메이븐 같은 빌드 툴과 스크립트를 사용하고 있다면, 
>빌드 툴에서 제공하는 JUnit플러그인이나 태스크를 이용해 JUnit테스트를 실행 할 수 있다.
>여러 개발자가 만든 코드를 모두 통합에서 테스트를 수행해야 할 떄도 있다. 
>이런 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스틑를 수행 하는 것이 좋다.
>이떄 빌드  스크립트를 이욯해 JUnit를 테스트를 실행하면 된다.

빌드 툴 
-----------------
>단위 테스트는 코드가 바뀌지 않는다면 매번 동일한 테스트 결과를 얻을 수 있어야 한다.
>테스트 하기 전에 테스트 실행 문제 가 되지 않는 상태를 만들어주는 편이 좋다.
>단위 테스틑 항상 일관성 있는 결과가 보장되야 한다.

포괄적인 테스트 
-----------------

>꼼꼼한 테스트를 해보는 것이 좋은 자세다. 테스트를 안 만드는 것도 위험한 일이지만, 
>성의 없이 테스트를 만드는 위엄하다

getCount() 테스트
-----------------

>테스트 메소드는 한번에 한 가지 검증 목적에 충실해야 하는것이 좋다.
>JUnit 실행 순서를 보장 해주지 않는다.
>테스트의 결과가 테스트 길행 순서에 영상을 받는다면 잘못 만든것이다.



getCount() 예외조건에 대한 테스트
-----------------

*get()에 정보가 없다면*
>1.null같은 특별한 값을 리턴
>2.예외를 던지는 것  
>@Test애노테이션의 expected엘리먼트는 테스트 메소드 실행 중에 발생하리라 기대하는 예외 클래스를 넣어주면 된다.
>expected에서 예외가 던져지면 성공, 아니면 실패이다.



포괄적인 테스트
-----------------

>개발자는 자신이 만든 코드에서 발생할 수 있는 다양한 상항과 입력 값을 고려하는 포괄적인 테스트를 만들 수 있다.
>테스트를 작성 할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

테스트를 이끄는 개발
-----------------

>테스트할  코드를 안만들고 테스트 코드부터 만드는 순서는 
>개발릉 진행하는 구체적인 개발 전략이 실재로 존재한다. 많은 개발자가 적극적으로 사용하고 있다.
>테스트 코드는 하나의 기능적의서 처럼 보인다.
>그래서 기능 설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 
>테스트 코드가 일부분을 담당하고 있다고 볼수 있다.
>실제 애플리케이션을 만들고 나면 태스트를 실행 해서  설계한 대로 코드가 동작하는지 빠르게 검증할수 있다.
>만약 테스가 실패하면 이떄는 설계한 대로 코드가 만들어지지 않았음을 바로 알수 있다.
>그리고 문제가 되는 부분을 무엇인지에 대한 정보도 테스트 걸과를 통해 얻을 수 있다.

테스트 주도 개발
-----------------

*테스트 주도 개발(TDD), 테스트 우선 개발*
>만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고
>테스트를 성공하게 해주는 코드를 작성한 방식

>TDD는 테스트를 먼저 만들고 그 테스트가 성곻하도록 하는 코드만 만드는 식으로 진행하기 때문에  
>테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다.
>또한 테스트를 작성하는 시간과 애프리케이션 코드를 작성하는 시간의 간격 짧아 진다.
>TDD를 하면 자연스럽게 단위 테스트를 만들수 있다.
>머릿속에서 진행되는 테스트는 제약이 심하고, 오류가 많고, 나중에 반복하기가 힘들다 

@Before
-----------------

*Before : JUnit에서 제공하는 애노테이션 @Test가 실행되기전에 먼저 실행한다*

*JUnit 테스트 수행하는 방식*
>1.테스트 클래스에서 @Test가 붙은 publid이고 void형이며 파라미터가 없는 테스트메소드를 모두 찾는다.
>2.테스트 클래스의 오브젝트는 하나 만든다.
>3.@Before가 붙은 메소드가 있으면 실행한다.
>4.@Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장한다.
>5.@After가 붙은 메소드가 있으면 실행한다.
>6.나머지 테스트 메소드에 대해 2~5번을 반복한다.
>7.모든 테스트의 력과를 종합해서 돌린다.

>각 테스트가 영향을 주지 한고 독립적으로 실행됨을 확실 보장해주기 위해 매번 새로운 오브젝트를 만든다.


픽스처
-----------------

>태스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.
>픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before메소드를 이용해 생성두면 편리하다