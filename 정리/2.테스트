>>스프링의 중요한 가치는 IoC/DI와 테스트 이다.

*IoC/DI : 오브제트의 설계와 생성, 관계, 사용헤 관하 기술*
*태스트 : 코드를 확신할 수 있게 해주고 , 변화에 유연하게 대처 할 수 있는 자신감을 주는 테스트 기술*

UserDaoTest다시보기
---------------------
>1장에서 매 단계를 확인하고 다양한 방법으로 초남감 UserDao 코드의 구조와 설계를 개선했고, 스프링을 적용해서 동작하게 만들었다. 
>코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 초남감 UserDao 가능을 수행한다,
>테스트를 통해 확인 할수 없었다면 확신 할 수 없었을 것이다.
>테스트란 코드가 정확히 동작하는지를 확인힌해서 확신할 수 있는 작업이다.

*테스트 -> 설계의 결함이 있는 작업 -> 결함을 제거하는 디버깅 작업 -> 확신을 가진 코드

웹을 톤한DaO 테스트 방법의 문제점
------------------------------

>보통 웹 프로그램에서 사용한는 DAO를 테스트하는 방법은 DAO를 만든 위 바로 테스트하지 않고, 서비스 계층 MVC 프레젠체이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다.
>웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이다.

##단점##
*모든 레이어의 기능을 다 만들고 나서야 태스트 가능*
>테스트를 하는 중에 에러가 나거나 테스트에 실패했다면, 과연 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요하다
>UserDao를 테스트 하고 피었는데 다른 계층의 코드와 컴포넌드, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 
>번거롭고, 오류가 있을 떄 빠르고 정확하게 대응하기 힘들다.

작은 단위의 테스트
-----------------

>테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하나.
>
>따라서  테스트는 작은  단위로 쪼개서 집중해서 할 수 있어야 한다.
>관심사의 분리하는 원리가 여기에 적용된다. 데스트의 관심이 다르다면 데스트할 대상을 분리하고 집중해서 접근해야 한다.

> UserDaoTest는 한 가지 관심에 집중할 수 있게  작은 단위로 만들어진 테스트다.
>간단히 IDE나 도스창에서도 테스트 수행이 가능하다. 에러가 나거나 원치 않은 결과가 나온다면, UserDao에 문제가 있는 것이니 원인을 빠르게 찾아낼 수 있다
> 이렇게 작은 단위의 코드드에 다해 테스트를 수행한 것은 *단위 테스트*라고 한다.
> 단위란 크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고, 작게 보자면 UserDao의 add() 메소드 하나만 가지고 하나의 단위라고 생각할수 있다.
> 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
>일반적으로 단위는 작을수 록 좋다. 단위를 넘어서는 다른 코드들을 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.
>DB의 상태가 매번 달달지고 , 테스트를 위해 DB를 특정 상태로 만들줄수 없다면 UserDaoTestrk 단위 데스트로서 가치가 없다
>통제 할수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다
>전 과정을 하나로 묵어서 테스트 할 필요가 있다. 각 된위 기능을 잘 동작하는데 묶어놓으면 안 되는 경우가 종종 발생하기 때문이다. 
>길고 많은 다위가 참여하는 테스트도 필요하다.
> 단위별로 테스틀르 먼저 진행하고 긴테스틀르 시작하면 예외가 발생하거나 테스트 실패할 수는 있겠지만 
>이미 각 단위별로 검증을 마치고 오류를 잡았으므로 훨씬 나을 것이다.
>단위 테스트가 필요한 이유눈 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하를 개발바 스스로 확인하기 위해서다.
>이떄 확인의 대상과 조건이 간다하고 명확할수록 좋다.  
>단위 테스트트 개발자 만든 코드를 스스로 확인하기 위해 사용하는데 이를 개발자 테스트 또느 프로그래머 테스트라고 한다.
>UserDaoTest은 작은 단위의 테이터 액세스 기능만을 테스트 하다 그 외의 계층이 참여하지 않기 떄문에  이는 단위 테스트이다.
>또한 설께하고 의도한 대로 동작했는지를 확인하기 떄문에 개발자 테스트라고 한다.

자동수행 테스트 코드
-----------------

>테스트는 자동으로 수행되도록 코드로 만들어지 것이 중요하다.
>테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어 져서 자동으로 수행될 쉬 있어야 한다는 건 매우 중요하다.
>애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 별도로 테스트용 클래스를 만들어서 테스트 코도를 넣는 편이 낫다.
>자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다.
> 단 한줄의 코드를 건드렸는 전체 기능에 영향을 주기도 한다. 에플리케이션에 김각한 문제를 일키지는 않을까 하는 두려움을 앞선다.
>그럴때 만들어둔 테스트가 있다면 가른 기능에 문제가 발생하지는 않는지 재빨리 확인 할 수 있다. 

지속적인 개선과 점진적인 개발을 위한 테스트
-----------------

>처음 부터 개발을 끝내고 검즘하려고 한다면, 아마 쏟아지는 에러로 원인을 찾는데 고심스러운 시간을 보내야 한다.
>하지만 일단 단순한 벙법으로 정상적인 코드를 만들어 테스트 해뒀기 떄문에 작운 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다. 
>테스트를 수행해서 확신을 가지는 코드가 되었다.

UserDaoTest의 문제점
-----------------

*수동 확인 작업의 번거로움*
>사람의 눈으로 확인하는 과정이 필요하다.
>add()의 정보와 get()의 정보가 일치 하는지 테스트 코드는 확인해 주진 않는다.
>성공적으로 되고 있는지 확인하는 것은 사람의 책임이다.
>검증해야 하는 양이 많고 복잡해지면 역시 불편하고, 발견하지 못하고 넘어가는 실수를 할 가능성이 있다.

*실행  작업의 번거로움*
>가단한 실행 가능한 main() 메소드라고 하더라도 매번 그것을 실행하는 것은 제법 번거롭다.

테스트의 효율적인 수행과 결과 관리
-----------------

>프레임워크의 기본 동작원리가 바로 제어의 역저(IoC)이다. 개발자가 만든 크래스의 오브젝트를 생성하고 샐행하는 일은 프레임워크에 의해 진행된다.
>main()메소드노 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들필요도 없다.
>main()메소드 테스트는 프레임워크에 적용하기 적합하지 않다. main()메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이다.

*JUnit*
>1.public 메소드 선언
>2.@Test라는  애노테이션을 붙혀주는 것이다. 

검증 코드 전환
-----------------

*JUnit 제공하는 방법*
>if(!user.getName().equals(user2.getName())){.....}  = assertThat(user2.getName(), is(user.getName());